


import re
import logging
from datetime import datetime
import os
from socket import gethostname
from enum import Enum
from PySide6 import QtCore
# from PyQt5.QtCore import pyqtProperty, QVariant, QObject, pyqtSignal, pyqtSlot, QMessageLogger, qInstallMessageHandler
from io import StringIO
from config import LOGS_DIR
# from



LOGGER_NAME = 'FRAMCam'

# put logs at root dir, make folder if not there
class QtMessageType(Enum):
    """
    QtMsgType is supposed to be an enum, but doesn't seem to be implemented as an Enum

    QtDebugMsg	0	A message generated by the qDebug() function.
    QtInfoMsg	4	A message generated by the qInfo() function.
    QtWarningMsg	1	A message generated by the qWarning() function.
    QtCriticalMsg	2	A message generated by the qCritical() function.
    QtFatalMsg	3	A message generated by the qFatal() function.
    """
    QtDebugMsg = 0
    QtInfoMsg = 4
    QtWarningMsg = 1
    QtCriticalMsg = 2
    QtFatalMsg = 3

# class QtMessageType(Enum):
#     """
#     QtMsgType is supposed to be an enum, but doesn't seem to be implemented as an Enum
#
#     QtDebugMsg	0	A message generated by the qDebug() function.
#     QtInfoMsg	4	A message generated by the qInfo() function.
#     QtWarningMsg	1	A message generated by the qWarning() function.
#     QtCriticalMsg	2	A message generated by the qCritical() function.
#     QtFatalMsg	3	A message generated by the qFatal() function.
#     """
#     QtDebugMsg = 0
#     QtInfoMsg = 4
#     QtWarningMsg = 1
#     QtCriticalMsg = 2
#     QtFatalMsg = 3

class Logger:
    """
    Basic logger class to use across scripts
    """
    def __init__(self):
        self._name = LOGGER_NAME
        self._log_dir = LOGS_DIR
        os.makedirs(self._log_dir, exist_ok=True)
        self._level = logging.DEBUG  # if we can't get anything from the SETTINGS table
        self._format = self._name + ': %(asctime)s %(levelname)s %(filename)s (%(lineno)s) "%(message)s"'
        self._date_format = '%Y-%m-%dT%H:%M:%S'

        self._logger = None
        self._formatter = None
        self._file_handler = None
        self._stream_handler = None
        self.configure()

    def configure(self):
        """
        call me once on init of the app, then we just use get_root_logger
        else where to re-use the root logger
        """
        self._logger = logging.getLogger(self._name)
        self._logger.setLevel(self._level)
        self._formatter = logging.Formatter(fmt=self._format, datefmt=self._date_format)
        logging.basicConfig(format=self._format)  # format needs to be set on root logger for console

        # setup console logger
        self._console = logging.StreamHandler(StringIO())
        self._console.setFormatter(self._formatter)
        self._logger.addHandler(self._console)

        # setup file logger
        self._file = logging.FileHandler(
            self._get_todays_log_file(),
            mode='a'
        )
        self._file.setFormatter(self._formatter)
        self._logger.addHandler(self._file)

        QtCore.qInstallMessageHandler(self._qt_msg_handler)

        return self.get_root()

    def _get_todays_log_file(self):
        """
        Get log file for today, define here so we can use when setting up log db file (or txt)
        :param ext: specify extension
        :return: str, log db file name
        """
        return os.path.join(self._log_dir, f"{self._name}_{gethostname()}_{datetime.now().strftime('%Y%m%d')}.txt")

    def _qt_msg_handler(self, msg_type, msg_log_context, msg_string):
        """
        Redirect QML logs to python logger here.  Creating log record with QML info allows us to
        capture qml file and line where log originated.
        :param msg_type: QtMsgType enum(debug, info, etc)
        :param msg_log_context: QMessageLogContext
        :param msg_string: Debug message
        """
        try:
            if msg_log_context is None:
                # Weird case, handle gracefully
                raise ValueError('msg_log_context is None')

            if msg_string is None:
                return

            base_file = msg_log_context.file.split('/')[-1] if msg_log_context.file else None

            # QML logs sometimes list "qrc:/qml/obsever/$QMLFILE :lineno:colno" prefix, subbing out below
            msg_string = re.sub(f'qrc:/qml/[A-z]+/{base_file}[:|\d]+', '', msg_string).strip()
            # msg_string = re.sub()

            qt_to_pthon_level_map = {
                QtMessageType.QtDebugMsg.value: logging.DEBUG,
                QtMessageType.QtInfoMsg.value: logging.INFO,
                QtMessageType.QtWarningMsg.value: logging.WARNING,
                QtMessageType.QtFatalMsg.value: logging.ERROR,
                QtMessageType.QtCriticalMsg.value: logging.CRITICAL
            }

            try:
                python_level = qt_to_pthon_level_map[msg_type.value]
            except KeyError as e:
                self._logger.error(f"{type(msg_type)} {msg_type} ")
                self._logger.warning(f"Unknown QT msg type {msg_type}; {e}")
                return

            # logger.handle doesn't seem to filter on level, so adding if stmt
            if self._logger.isEnabledFor(python_level):
                self._logger.handle(
                    logging.LogRecord(
                        name=self._name,
                        level=python_level,
                        pathname=base_file,
                        lineno=msg_log_context.line,
                        msg=msg_string,
                        exc_info=None,
                        args=None
                    )
                )
        except Exception as e:
            self._logger.error(f'Unable to handle Qt log; {e}')

    @staticmethod
    def get_root():
        """
        return root logger configured w/ basic config above
        :return: logger obj
        """
        return logging.getLogger(LOGGER_NAME)


if __name__ == '__main__':
    l = Logger()
    l.configure()
    logger = l.get_root()
    logger.info("THIS IS A An info LOG")
    logger.debug("THIS IS A An debug LOG")